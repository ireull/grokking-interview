### 1. В чем разница между событиями **`mouseenter`** и **`mouseover`** в JavaScript и браузерах?

<details>
<summary>Показать ответ</summary>

**Краткий ответ:**
Основное отличие заключается в поведении всплытия (bubbling) событий mouseenter и mouseover. mouseenter не всплывает, в то время как mouseover всплывает.

**mouseenter события не всплывают.** Событие mouseenter срабатывает только когда указатель мыши входит в сам элемент, а не в его потомков. Если родительский элемент имеет дочерние элементы, и указатель мыши входит в дочерние элементы, событие mouseenter не будет повторно вызвано на родительском элементе — оно срабатывает только один раз при входе в родительский элемент, независимо от его содержимого. Если и к родительскому, и к дочернему элементам прикреплены обработчики mouseenter, и указатель мыши перемещается с родительского элемента на дочерний, mouseenter сработает только для дочернего.

**mouseover события всплывают** вверх по DOM-дереву. Событие mouseover срабатывает, когда указатель мыши входит в элемент или в один из его потомков. Если родительский элемент имеет дочерние элементы, и указатель мыши входит в дочерние элементы, событие mouseover также будет повторно срабатывать на родительском элементе. Если родительский элемент имеет несколько дочерних элементов, это может привести к срабатыванию нескольких обратных вызовов событий. Если есть дочерние элементы, и указатель мыши перемещается с родительского элемента на дочерний, mouseover сработает как для родительского, так и для дочернего элемента.

| Свойство     | mouseenter                     | mouseover                                      |
| ------------ | ------------------------------ | ---------------------------------------------- |
| Всплытие     | Нет                            | Да                                             |
| Срабатывание | Только при входе в сам элемент | При входе в сам элемент и при входе в потомков |

**Событие mouseenter:**

- **Не всплывает:** Событие mouseenter не всплывает. Оно срабатывает только когда указатель мыши входит в элемент, к которому прикреплен обработчик события, а не когда он входит в любые дочерние элементы.
- **Срабатывает один раз:** Событие mouseenter срабатывает только один раз, когда указатель мыши входит в элемент, что делает его более предсказуемым и легким в управлении в определенных сценариях.
- Пример использования mouseenter — когда вы хотите определить вход мыши в элемент, не беспокоясь о том, что дочерние элементы многократно вызывают событие.

**Событие mouseover:**

- **Всплывает вверх по DOM:** Событие mouseover всплывает вверх по DOM. Это означает, что если у вас есть обработчик события на родительском элементе, он также сработает, когда указатель мыши перемещается над любыми дочерними элементами.
- **Срабатывает несколько раз:** Событие mouseover срабатывает каждый раз, когда указатель мыши перемещается над элементом или любым из его дочерних элементов. Это может привести к множественным срабатываниям, если у вас есть вложенные элементы.
- Пример использования mouseover — когда вы хотите определить, когда мышь входит в элемент или любой из его дочерних элементов, и вас устраивает многократное срабатывание событий.

**Пример**

Вот пример, демонстрирующий разницу между событиями mouseover и mouseenter:

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Mouse Events Example</title>
    <style>
      .parent {
        width: 200px;
        height: 200px;
        background-color: lightblue;
        padding: 20px;
      }
      .child {
        width: 100px;
        height: 100px;
        background-color: lightcoral;
      }
    </style>
  </head>
  <body>
    <div class="parent">
      Parent Element
      <div class="child">Child Element</div>
    </div>

    <script>
      const parent = document.querySelector(".parent");
      const child = document.querySelector(".child");

      // Mouseover event on parent.
      parent.addEventListener("mouseover", () => {
        console.log("Mouseover on parent");
      });

      // Mouseenter event on parent.
      parent.addEventListener("mouseenter", () => {
        console.log("Mouseenter on parent");
      });

      // Mouseover event on child.
      child.addEventListener("mouseover", () => {
        console.log("Mouseover on child");
      });

      // Mouseenter event on child.
      child.addEventListener("mouseenter", () => {
        console.log("Mouseenter on child");
      });
    </script>
  </body>
</html>
```

**Ожидаемое поведение**

- Когда мышь входит в родительский элемент:
  - Событие `mouseover` на родительском элементе сработает.
  - Событие `mouseenter` на родительском элементе сработает.
- Когда мышь входит в дочерний элемент:
  - Событие `mouseover` на родительском элементе сработает снова, потому что `mouseover` всплывает от дочернего элемента.
  - Событие `mouseover` на дочернем элементе сработает.
  - Событие `mouseenter` на дочернем элементе сработает.
  - Событие `mouseenter` на родительском элементе **не** сработает снова, потому что `mouseenter` не всплывает.

</details>

### 2. Объясните разницу между **`document.querySelector()`** и **`document.getElementById()`**

<details>
<summary>Показать ответ</summary>

**Краткий ответ:**
`document.querySelector()` и `document.getElementById()` — это методы для выбора элементов из DOM, но у них есть ключевые различия. `document.querySelector()` может выбирать любой элемент, используя CSS-селектор, и возвращает первое совпадение, в то время как `document.getElementById()` выбирает элемент по его ID и возвращает элемент с этим конкретным ID.

```javascript
// Использование document.querySelector()
const element = document.querySelector(".my-class");
// Использование document.getElementById()
const elementById = document.getElementById("my-id");
```

**Разница между `document.querySelector()` и `document.getElementById()`**

`document.querySelector()`

- Может выбирать элементы, используя любой валидный CSS-селектор, включая класс, ID, тег, атрибут и псевдоклассы
- Возвращает первый элемент, соответствующий указанному селектору
- Более универсальный, но немного медленнее из-за гибкости CSS-селекторов

```javascript
// Выбрать первый элемент с классом 'my-class'
const element = document.querySelector(".my-class");
// Выбрать первый элемент <div>
const divElement = document.querySelector("div");
// Выбрать первый элемент с атрибутом data-role='button'
const buttonElement = document.querySelector('[data-role="button"]');
```

`document.getElementById()`

- Выбирает элемент по его атрибуту ID
- Возвращает элемент с указанным ID
- Быстрее и эффективнее для выбора элементов по ID, но менее универсальный

```javascript
// Выбрать элемент с ID 'my-id'
const elementById = document.getElementById("my-id");
```

**Ключевые отличия**

- **Тип селектора**: `document.querySelector()` использует CSS-селекторы, в то время как `document.getElementById()` использует только атрибут ID.
- **Возвращаемое значение**: `document.querySelector()` возвращает первый совпадающий элемент, тогда как `document.getElementById()` возвращает элемент с указанным ID.
- **Производительность**: `document.getElementById()` обычно быстрее, потому что он напрямую обращается к элементу по ID, в то время как `document.querySelector()` должен анализировать CSS-селектор.
</details>

### 3. Как **`<iframe>`** на странице взаимодействуют между собой?

<details>
<summary>Показать ответ</summary>

**Краткий ответ:**
Элементы `<iframe>` на странице могут взаимодействовать с помощью API `postMessage`. Это позволяет осуществлять безопасную кросс-доменную коммуникацию между родительской страницей и iframe. Метод `postMessage` отправляет сообщение, а слушатель события `message` его получает. Вот простой пример:

```javascript
// В родительской странице
const iframe = document.querySelector("iframe");
iframe.contentWindow.postMessage("Hello from parent", "*");

// В iframe
window.addEventListener("message", (event) => {
  console.log(event.data); // 'Hello from parent'
});
```

**Как `<iframe>` на странице взаимодействуют?**

**Использование API `postMessage`**
API `postMessage` — это наиболее распространенный и безопасный способ для iframe-элементов взаимодействовать друг с другом или с их родительской страницей. Этот метод позволяет осуществлять кросс-доменную коммуникацию, что крайне важно для современных веб-приложений.

**Отправка сообщения**
Чтобы отправить сообщение с родительской страницы в iframe, вы можете использовать метод `postMessage`. Вот пример:

```javascript
// В родительской странице
const iframe = document.querySelector("iframe");
iframe.contentWindow.postMessage("Hello from parent", "*");
```

В этом примере родительская страница выбирает iframe и отправляет ему сообщение. Второй параметр, `'*'`, — это целевой источник (target origin). Он указывает источник целевого окна. Использование `'*'` означает, что сообщение может быть получено любым источником, но в целях безопасности лучше указывать точный источник.

**Получение сообщения**
Чтобы получить сообщение в iframe, вам нужно добавить слушатель события для события `message`:

```javascript
// В iframe
window.addEventListener("message", (event) => {
  console.log(event.data); // 'Hello from parent'
});
```

Объект `event` содержит свойство `data`, которое хранит сообщение, отправленное родительской страницей.

**Соображения безопасности**
При использовании `postMessage` важно учитывать безопасность:

- **Указывайте целевой источник**: Вместо использования `'*'` укажите точный источник, чтобы гарантировать, что только сообщения из доверенных источников будут получены.
- **Проверяйте сообщение**: Всегда проверяйте содержимое сообщения, чтобы предотвратить обработку вредоносных данных.

**Пример с указанием целевого источника**
Вот пример с указанным целевым источником:

```javascript
// В родительской странице
const iframe = document.querySelector("iframe");
const targetOrigin = "https://example.com";
iframe.contentWindow.postMessage("Hello from parent", targetOrigin);

// В iframe
window.addEventListener("message", (event) => {
  if (event.origin === "https://parent.com") {
    console.log(event.data); // 'Hello from parent'
  }
});
```

В этом примере родительская страница отправляет сообщение только на `https://example.com`, а iframe обрабатывает сообщение только если оно пришло с `https://parent.com`.

</details>

### 4. Как добавлять, удалять и изменять HTML-элементы с помощью JavaScript?

<details>
<summary>Показать ответ</summary>

**Краткий ответ:**
Для добавления, удаления и изменения HTML-элементов с помощью JavaScript можно использовать методы, такие как `createElement`, `appendChild`, `removeChild`, и свойства, такие как `innerHTML` и `textContent`. Например, чтобы добавить элемент, вы можете создать его с помощью `document.createElement`, а затем добавить к родительскому элементу с помощью `appendChild`. Чтобы удалить элемент, можно использовать `removeChild` у его родителя. Чтобы изменить элемент, можно изменить его `innerHTML` или `textContent`.

```javascript
// Добавление элемента
const newElement = document.createElement("div");
newElement.textContent = "Hello, World!";
document.body.appendChild(newElement);

// Удаление элемента
const elementToRemove = document.getElementById("elementId");
elementToRemove.parentNode.removeChild(elementToRemove);

// Изменение элемента
const elementToModify = document.getElementById("elementId");
elementToModify.innerHTML = "New Content";
```

**Добавление, удаление и изменение HTML-элементов с помощью JavaScript**

**Добавление элементов**
Чтобы добавить HTML-элемент, вы можете использовать метод `document.createElement` для создания нового элемента, а затем добавить его к родительскому элементу с помощью `appendChild`.

```javascript
// Создание нового div элемента
const newDiv = document.createElement("div");
// Установка его содержимого
newDiv.textContent = "Hello, World!";
// Добавление нового элемента в body
document.body.appendChild(newDiv);
```

Вы также можете использовать `insertBefore` для вставки нового элемента перед существующим дочерним элементом.

```javascript
const parentElement = document.getElementById("parent");
const newElement = document.createElement("p");
newElement.textContent = "Inserted Paragraph";
const referenceElement = document.getElementById("reference");
parentElement.insertBefore(newElement, referenceElement);
```

**Удаление элементов**
Чтобы удалить HTML-элемент, вы можете использовать метод `removeChild` на его родительском элементе.

```javascript
// Выбрать элемент для удаления
const elementToRemove = document.getElementById("elementId");
// Удалить элемент
elementToRemove.parentNode.removeChild(elementToRemove);
```

Альтернативно, вы можете использовать метод `remove` непосредственно на элементе.

```javascript
const elementToRemove = document.getElementById("elementId");
elementToRemove.remove();
```

**Изменение элементов**
Чтобы изменить HTML-элемент, вы можете изменить его свойства, такие как `innerHTML`, `textContent` или атрибуты.

```javascript
// Выбрать элемент для изменения
const elementToModify = document.getElementById("elementId");
// Изменить его внутренний HTML
elementToModify.innerHTML = "New Content";
// Изменить его текстовое содержимое
elementToModify.textContent = "New Text Content";
// Изменить атрибут
elementToModify.setAttribute("class", "new-class");
```

Вы также можете использовать методы, такие как `classList.add`, `classList.remove` и `classList.toggle`, для изменения классов элемента.

```javascript
const element = document.getElementById("elementId");
// Добавить класс
element.classList.add("new-class");
// Удалить класс
element.classList.remove("old-class");
// Переключить класс
element.classList.toggle("active");
```

</details>

### 5. В чем разница между **`event.preventDefault()`** и **`event.stopPropagation()`**?

<details>
<summary>Показать ответ</summary>

**Краткий ответ:**
`event.preventDefault()` используется для предотвращения действия по умолчанию, которое принадлежит событию, например, предотвращение отправки формы. `event.stopPropagation()` используется для остановки всплытия события к родительским элементам, предотвращая выполнение любых обработчиков событий родителей.

**В чем разница между `event.preventDefault()` и `event.stopPropagation()`?**

`event.preventDefault()`
`event.preventDefault()` — это метод, который отменяет событие, если оно отменяемо, что означает, что действие по умолчанию, которое принадлежит событию, не произойдет. Например, это можно использовать для предотвращения отправки формы:

```javascript
document.querySelector("form").addEventListener("submit", function (event) {
  event.preventDefault();
  // Отправка формы предотвращена
});
```

`event.stopPropagation()`
`event.stopPropagation()` — это метод, который предотвращает всплытие события вверх по DOM-дереву, останавливая уведомление любых родительских обработчиков о событии. Это полезно, когда вы хотите обработать событие на определенном уровне и не хотите, чтобы оно запускало обработчики на родительских элементах:

```javascript
document.querySelector(".child").addEventListener("click", function (event) {
  event.stopPropagation();
  // Событие клика не будет распространяться к родительским элементам
});
```

**Ключевые отличия**

- `event.preventDefault()` останавливает действие по умолчанию, связанное с событием.
- `event.stopPropagation()` останавливает распространение (всплытие) события к родительским элементам.

**Примеры использования**

- Используйте `event.preventDefault()`, когда хотите предотвратить поведение элемента по умолчанию, например, переход по ссылке или отправку формы.
- Используйте `event.stopPropagation()`, когда хотите предотвратить достижение событием родительских элементов, что может быть полезно в сложных пользовательских интерфейсах, где несколько элементов имеют обработчики событий.
</details>

### 6. В чем разница между **`innerHTML`** и **`textContent`**?

<details>
<summary>Показать ответ</summary>

**Краткий ответ:**
`innerHTML` и `textContent` — это свойства, используемые для получения или установки содержимого HTML-элемента, но они служат разным целям. `innerHTML` возвращает или устанавливает HTML-разметку, содержащуюся внутри элемента, что означает, что он может анализировать и отображать HTML-теги. С другой стороны, `textContent` возвращает или устанавливает текстовое содержимое элемента, игнорируя любые HTML-теги и отображая их как обычный текст.

```javascript
// Пример innerHTML
element.innerHTML = "<strong>Bold Text</strong>"; // Отображается как жирный текст

// Пример textContent
element.textContent = "<strong>Bold Text</strong>"; // Отображается как обычный текст: <strong>Bold Text</strong>
```

**Разница между `innerHTML` и `textContent`**

`innerHTML`
`innerHTML` — это свойство, которое позволяет получать или устанавливать HTML-разметку, содержащуюся внутри элемента. Оно может анализировать и отображать HTML-теги, что делает его полезным для динамического обновления структуры веб-страницы.

**Пример**

```javascript
const element = document.getElementById("example");
element.innerHTML = "<strong>Bold Text</strong>"; // Это будет отображаться как жирный текст
```

**Примеры использования**

- Динамическое добавление или обновление HTML-содержимого
- Отображение HTML-тегов и элементов

**Соображения безопасности**
Использование `innerHTML` может подвергнуть ваше приложение атакам межсайтового скриптинга (XSS), если вы вставляете ненадежное содержимое. Всегда очищайте любой пользовательский ввод перед установкой его как `innerHTML`.

`textContent`
`textContent` — это свойство, которое позволяет получать или устанавливать текстовое содержимое элемента. Оно игнорирует любые HTML-теги и отображает их как обычный текст, что делает его более безопасным для вставки контента, созданного пользователем.

**Пример**

```javascript
const element = document.getElementById("example");
element.textContent = "<strong>Bold Text</strong>"; // Это будет отображаться как обычный текст: <strong>Bold Text</strong>
```

**Примеры использования**

- Безопасная вставка контента, созданного пользователем
- Удаление HTML-тегов из строки

**Соображения производительности**
`textContent` обычно работает быстрее, чем `innerHTML`, потому что не анализирует и не отображает HTML-теги. Оно просто обновляет текстовое содержимое элемента.

</details>

### 7. Что такое DOM и как он структурирован?

<details>
<summary>Показать ответ</summary>

**Краткий ответ:**
DOM, или Document Object Model (Объектная Модель Документа), — это программный интерфейс для веб-документов. Он представляет страницу таким образом, что программы могут изменять структуру документа, стиль и содержимое. DOM структурирован как дерево объектов, где каждый узел представляет часть документа, такую как элементы, атрибуты и текст.

**Что такое DOM и как он структурирован?**

**Определение**
Document Object Model (DOM) — это кроссплатформенный и независимый от языка интерфейс, который обрабатывает HTML, XHTML или XML документ как древовидную структуру. Каждый узел в этом дереве представляет часть документа.

**Структура**
DOM структурирован как иерархическое дерево узлов. Вот основные типы узлов:

1. **Узел документа (Document node)**: Корень дерева документа. Представляет весь документ.
2. **Узлы элементов (Element nodes)**: Представляют HTML-элементы и составляют основную часть дерева документа.
3. **Узлы атрибутов (Attribute nodes)**: Связаны с узлами элементов и представляют атрибуты этих элементов.
4. **Текстовые узлы (Text nodes)**: Представляют текстовое содержимое внутри элементов.
5. **Узлы комментариев (Comment nodes)**: Представляют комментарии в HTML.

**Пример**
Рассмотрим следующий HTML:

```html
<!DOCTYPE html>
<html>
  <head>
    <title>Document</title>
  </head>
  <body>
    <h1>Hello, World!</h1>
    <p>This is a paragraph.</p>
  </body>
</html>
```

Дерево DOM для этого документа будет выглядеть так:

```
Document
 └── html
     ├── head
     │   └── title
     │       └── "Document"
     └── body
         ├── h1
         │   └── "Hello, World!"
         └── p
             └── "This is a paragraph."
```

**Доступ и манипулирование DOM**
JavaScript может использоваться для доступа и манипулирования DOM. Вот некоторые распространенные методы:

- `document.getElementById(id)`: Выбирает элемент по его ID.
- `document.querySelector(selector)`: Выбирает первый элемент, который соответствует CSS-селектору.
- `element.appendChild(node)`: Добавляет новый дочерний узел к элементу.
- `element.removeChild(node)`: Удаляет дочерний узел из элемента.

Пример:

```javascript
// Выбрать элемент <h1>
const heading = document.querySelector("h1");
// Изменить его текстовое содержимое
heading.textContent = "Hello, DOM!";
```

</details>

### 8. В чем разница между "атрибутом" и "свойством" в DOM?

<details>
<summary>Показать ответ</summary>

**Краткий ответ:**
Атрибуты определяются в HTML и предоставляют начальные значения для свойств. Свойства являются частью DOM и представляют текущее состояние элемента. Например, атрибут `value` элемента `<input>` устанавливает его начальное значение, в то время как свойство `value` отражает текущее значение при взаимодействии пользователя с ним.

**Разница между "атрибутом" и "свойством" в DOM**

**Атрибуты**
Атрибуты определяются в HTML-разметке и предоставляют начальные значения для элементов. Они статичны и не меняются после загрузки страницы, если только они не изменены явно с помощью JavaScript.

**Пример**

```html
<input type="text" value="initial value" />
```

В этом примере `value="initial value"` является атрибутом.

**Свойства**
Свойства являются частью DOM и представляют текущее состояние элемента. Они динамичны и могут изменяться при взаимодействии пользователя со страницей или через JavaScript.

**Пример**

```javascript
const inputElement = document.querySelector("input");
console.log(inputElement.value); // Выводит текущее значение элемента input
inputElement.value = "new value"; // Изменяет текущее значение элемента input
```

В этом примере `value` является свойством объекта `inputElement`.

**Ключевые отличия**

- **Инициализация**: Атрибуты инициализируют свойства DOM.
- **Состояние**: Атрибуты статичны, в то время как свойства динамичны.
- **Доступ**: Доступ к атрибутам можно получить с помощью методов `getAttribute` и `setAttribute`, в то время как доступ к свойствам можно получить напрямую через объект DOM.

**Пример**

```html
<input id="myInput" type="text" value="initial value" />
```

```javascript
const inputElement = document.getElementById("myInput");

// Доступ к атрибуту
console.log(inputElement.getAttribute("value")); // "initial value"
// Доступ к свойству
console.log(inputElement.value); // "initial value"
// Изменение свойства
inputElement.value = "new value";
console.log(inputElement.value); // "new value"
console.log(inputElement.getAttribute("value")); // "initial value"
```

В этом примере изменение свойства `value` не влияет на атрибут `value`.

</details>

### 9. Опишите разницу между **`<script>`**, **`<script async>`** и **`<script defer>`**

<details>
<summary>Показать ответ</summary>

**Краткий ответ:**
Все эти способы (`<script>`, `<script async>` и `<script defer>`) используются для загрузки и выполнения JavaScript-файлов в HTML-документе, но они отличаются тем, как браузер обрабатывает загрузку и выполнение скрипта:

- `<script>` — это стандартный способ включения JavaScript. Браузер блокирует анализ HTML, пока скрипт загружается и выполняется. Браузер не продолжит рендеринг страницы, пока скрипт не завершит выполнение.
- `<script async>` загружает скрипт асинхронно, параллельно с анализом HTML. Выполняет скрипт, как только он становится доступным, потенциально прерывая анализ HTML. `<script async>` не ждут друг друга и выполняются в произвольном порядке.
- `<script defer>` загружает скрипт асинхронно, параллельно с анализом HTML. Однако выполнение скрипта откладывается до завершения анализа HTML, в том порядке, в котором они появляются в HTML.

Вот таблица, суммирующая 3 способа загрузки `<script>` в HTML-документе.

| Функция               | `<script>`            | `<script async>`                   | `<script defer>`                   |
| --------------------- | --------------------- | ---------------------------------- | ---------------------------------- |
| Поведение при анализе | Блокирует анализ HTML | Выполняется параллельно с анализом | Выполняется параллельно с анализом |
| Порядок выполнения    | В порядке появления   | Не гарантирован                    | В порядке появления                |
| Зависимость от DOM    | Нет                   | Нет                                | Да (ждет DOM)                      |

**Для чего нужны теги `<script>`**
Теги `<script>` используются для включения JavaScript на веб-странице. Атрибуты async и defer используются для изменения того, как/когда происходит загрузка и выполнение скрипта.

**`<script>`**
Для обычных тегов `<script>` без async или defer, когда они встречаются, анализ HTML блокируется, скрипт загружается и выполняется немедленно. Анализ HTML возобновляется после выполнения скрипта. Это может блокировать рендеринг страницы, если скрипт большой.

Используйте `<script>` для критически важных скриптов, от которых зависит правильное отображение страницы.

```html
<!DOCTYPE html>
<html>
  <head>
    <title>Regular Script</title>
  </head>
  <body>
    <!-- Содержимое перед скриптом -->
    <h1>Regular Script Example</h1>
    <p>This content will be rendered before the script executes.</p>
    <!-- Обычный скрипт -->
    <script src="regular.js"></script>
    <!-- Содержимое после скрипта -->
    <p>This content will be rendered after the script executes.</p>
  </body>
</html>
```

**`<script async>`**
В `<script async>` браузер загружает файл скрипта асинхронно (параллельно с анализом HTML) и выполняет его, как только он становится доступным (потенциально до завершения анализа HTML). Выполнение не обязательно будет происходить в том порядке, в котором он появляется в HTML-документе. Это может улучшить воспринимаемую производительность, потому что браузер не ждет загрузки скрипта, прежде чем продолжить рендеринг страницы.

Используйте `<script async>`, когда скрипт не зависит от других скриптов на странице, например, скрипты аналитики и рекламы.

```html
<!DOCTYPE html>
<html>
  <head>
    <title>Async Script</title>
  </head>
  <body>
    <!-- Содержимое перед скриптом -->
    <h1>Async Script Example</h1>
    <p>This content will be rendered before the async script executes.</p>
    <!-- Асинхронный скрипт -->
    <script async src="async.js"></script>
    <!-- Содержимое после скрипта -->
    <p>
      This content may be rendered before or after the async script executes.
    </p>
  </body>
</html>
```

**`<script defer>`**
Подобно `<script async>`, `<script defer>` также загружает скрипт параллельно с анализом HTML, но скрипт выполняется только тогда, когда документ полностью проанализирован и перед запуском события `DOMContentLoaded`. Если их несколько, каждый отложенный скрипт выполняется в том порядке, в котором они появились в HTML-документе.

Если скрипт зависит от полностью проанализированного DOM, атрибут `defer` будет полезен для обеспечения того, чтобы HTML был полностью проанализирован перед выполнением.

```html
<!DOCTYPE html>
<html>
  <head>
    <title>Deferred Script</title>
  </head>
  <body>
    <!-- Содержимое перед скриптом -->
    <h1>Deferred Script Example</h1>
    <p>This content will be rendered before the deferred script executes.</p>
    <!-- Отложенный скрипт -->
    <script defer src="deferred.js"></script>
    <!-- Содержимое после скрипта -->
    <p>This content will be rendered before the deferred script executes.</p>
  </body>
</html>
```

**Примечания**

- Атрибут `async` следует использовать для скриптов, которые не критичны для начального рендеринга страницы и не зависят друг от друга, в то время как атрибут `defer` следует использовать для скриптов, которые зависят от другого скрипта или от которых зависит другой скрипт.
- Атрибуты `async` и `defer` игнорируются для скриптов, которые не имеют атрибута `src`.
- `<script>` с `defer` или `async`, которые содержат `document.write()`, будут проигнорированы с сообщением вроде "A call to `document.write()` from an asynchronously-loaded external script was ignored" ("Вызов `document.write()` из асинхронно загруженного внешнего скрипта был проигнорирован").
- Несмотря на то, что `async` и `defer` помогают сделать загрузку скрипта асинхронной, скрипты всё равно в конечном итоге выполняются в основном потоке. Если эти скрипты требуют интенсивных вычислений, это может привести к зависанию/замораживанию пользовательского интерфейса. **Partytown** — это библиотека, которая помогает переместить выполнение скриптов в **веб-воркер** и вне **основного потока**, что отлично подходит для сторонних скриптов, код которых вы не контролируете.

</details>

### 10. Почему обычно рекомендуется размещать CSS **`<link>`** между **`<head></head>`**, а JS **`<script>`** перед закрывающим тегом **`</body>`**?

<details>
<summary>Показать ответ</summary>

**Краткий ответ:**
Если коротко, такое размещение CSS `<link>` и JavaScript `<script>` позволяет ускорить рендеринг страницы и улучшить общую производительность.

**Размещение `<link>` в `<head>`**
Размещение `<link>` в `<head>` является частью правильной спецификации при создании оптимизированного веб-сайта. Когда страница впервые загружается, HTML и CSS анализируются одновременно; HTML создает DOM (Document Object Model), а CSS создает CSSOM (CSS Object Model). Оба необходимы для создания визуального представления веб-сайта, обеспечивая быстрое время "первой значимой отрисовки" (first meaningful paint). Размещение CSS `<link>` в `<head>` гарантирует, что таблицы стилей загружены и готовы к использованию, когда браузер начинает рендеринг страницы.

Прогрессивный рендеринг — это метрика, по которой измеряется производительность сайтов. Размещение таблиц стилей ближе к концу документа — это то, что запрещает прогрессивный рендеринг во многих браузерах. Некоторые браузеры блокируют рендеринг, чтобы избежать необходимости перерисовывать элементы страницы, если их стили изменятся. Пользователь при этом вынужден смотреть на пустую белую страницу. В других случаях может наблюдаться мигание неоформленного содержимого (FOUC, Flash of Unstyled Content), которое показывает веб-страницу без применения стилей.

**Размещение `<script>` перед `</body>`**
Теги `<script>` блокируют анализ HTML во время загрузки и выполнения, что может замедлить отображение вашей страницы. Размещение `<script>` внизу позволит HTML быть проанализированным и отображенным пользователю в первую очередь.

Исключением для размещения `<script>` внизу является случай, когда ваш скрипт содержит `document.write()`, но в наши дни использование `document.write()` не считается хорошей практикой. Кроме того, размещение `<script>` внизу означает, что браузер не может начать загрузку скриптов до тех пор, пока весь документ не будет проанализирован. Это гарантирует, что ваш код, который должен манипулировать элементами DOM, не вызовет ошибку и не остановит выполнение всего скрипта. Если вам нужно разместить `<script>` в `<head>`, используйте атрибут `defer`, который достигнет того же эффекта запуска скрипта только после анализа HTML, но браузер может раньше начать сетевой запрос для загрузки скрипта.

Имейте в виду, что размещение скриптов непосредственно перед закрывающим тегом `</body>` создаст иллюзию, что страница загружается быстрее при пустом кеше (поскольку скрипты не будут блокировать загрузку остальной части документа). Однако, если у вас есть код, который вы хотите запустить во время загрузки страницы, он начнет выполняться только после того, как вся страница будет загружена. Если бы вы поместили эти скрипты в тег `<head>`, они начали бы выполняться раньше — поэтому при заполненном кеше страница фактически будет отображаться быстрее.

**Теги `<head>` и `<body>` теперь необязательны**
Согласно спецификации HTML5, определенные HTML-теги, такие как `<head>` и `<body>`, являются необязательными. Руководство по стилю Google даже рекомендует удалять их для экономии байтов. Однако эта практика все еще не широко распространена, и прирост производительности, вероятно, будет минимальным, и для большинства сайтов это, скорее всего, не будет иметь значения.

</details>

### 11. Рассмотрите HTML5 как открытую веб-платформу. Каковы строительные блоки **HTML5**?

<details>
<summary>Показать ответ</summary>

**Краткий ответ:**
HTML5 состоит из нескольких ключевых строительных блоков, которые образуют комплексную веб-платформу: семантика, стилизация, подключение, оффлайн-хранение, мультимедиа, 2D/3D графика, производительность и доступ к устройствам.

**Подробное объяснение**

- **Семантика (Semantics)**: HTML-теги описывают содержимое страницы.
- **Стилизация (Styling)**: Настройка внешнего вида HTML-тегов.
- **Подключение (Connectivity)**: Обеспечивает взаимодействие с сервером новыми и инновационными способами.
- **Оффлайн-хранение (Offline and storage)**: Позволяет веб-страницам хранить данные на стороне клиента локально и эффективнее работать в оффлайн-режиме.
- **Мультимедиа (Multimedia)**: Делает видео и аудио полноценными элементами открытой веб-платформы.
- **2D/3D графика и эффекты**: Предоставляет гораздо более разнообразные возможности представления контента.
- **Производительность (Performance)** и интеграция: Обеспечивает большую оптимизацию скорости и лучшее использование аппаратных ресурсов компьютера.
- **Доступ к устройствам (Device access)**: Позволяет использовать различные устройства ввода и вывода.
</details>

### 12. Для чего полезны атрибуты **`data-`**?

<details>
<summary>Показать ответ</summary>

**Краткий ответ:**
Атрибуты **`data-`** используются для хранения дополнительных данных в DOM, особенно когда нет более подходящих атрибутов или элементов. Они также часто применяются библиотеками и фреймворками для хранения служебной информации.

**Подробное объяснение**

До популяризации JavaScript-фреймворков разработчики использовали атрибуты `data-` для хранения дополнительных данных непосредственно в DOM, избегая таких хаков, как нестандартные атрибуты или дополнительные свойства DOM. Они предназначены для хранения пользовательских данных, специфичных для страницы или приложения, когда отсутствуют более подходящие атрибуты или элементы.

Другой распространенный вариант использования атрибутов `data-` — хранение информации, используемой сторонними библиотеками или фреймворками. Например, библиотека Bootstrap использует атрибуты data для настройки кнопок `<button>`, вызывающих действия в модальном окне в другом месте страницы.

**Пример кода**

```html
<button type="button" data-bs-toggle="modal" data-bs-target="#myModal">
  Launch modal
</button>
...
<div class="modal fade" id="myModal">Modal contents</div>
```

**Современные рекомендации**

В наши дни использование атрибутов `data-` обычно не рекомендуется. Одна из причин в том, что пользователи могут легко изменить атрибут data, используя функцию "inspect element" (инспектор элементов) в браузере. Модель данных лучше хранить в среде JavaScript и поддерживать синхронизацию с DOM через согласование виртуального DOM или двустороннее связывание данных, возможно, с помощью библиотеки или фреймворка.

Однако одно полностью обоснованное использование атрибутов data — добавление идентификатора для фреймворков **end-to-end** тестирования (например, Playwright, Puppeteer, Selenium) без добавления классов или атрибутов ID, предназначенных только для тестов, которые в первую очередь служат другим целям. Элементу нужен способ быть выбранным, и что-то вроде `data-test-id="my-element"` — это правильный способ сделать это, не усложняя семантическую разметку.

</details>

### 13. Что такое **прогрессивный рендеринг**?

<details>
<summary>Показать ответ</summary>

**Краткий ответ:**
Прогрессивный рендеринг (Progressive rendering) — это название техник, используемых для улучшения производительности веб-страницы (в частности, для улучшения воспринимаемого времени загрузки), чтобы отображать содержимое как можно быстрее.

**Подробное объяснение**

Прогрессивный рендеринг был гораздо более распространен в дни до широкополосного интернета, но он все еще используется в современной разработке, поскольку мобильные соединения становятся все более популярными (и ненадежными)!

**Основные техники прогрессивного рендеринга**

**Ленивая загрузка изображений (Lazy loading)**

Изображения на странице загружаются не все сразу. Изображение загружается только тогда, когда пользователь прокручивает до/рядом с частью страницы, которая отображает это изображение.

- `<img loading="lazy">` — это современный способ указать браузеру отложить загрузку изображений, находящихся за пределами экрана, до тех пор, пока пользователь не прокрутит страницу рядом с ними.
- Использование JavaScript для отслеживания позиции прокрутки и загрузки изображения, когда оно вот-вот появится на экране (путем сравнения координат изображения с позицией прокрутки).

**Приоритизация видимого содержимого (или рендеринг above-the-fold)**

Включение только минимально необходимых CSS/содержимого/скриптов для той части страницы, которая будет отображаться в браузере пользователя первой, чтобы отображать ее как можно быстрее. Затем можно использовать отложенные скрипты или прослушивать события `DOMContentLoaded`/`load` для загрузки других ресурсов и содержимого.

**Асинхронные HTML-фрагменты**

Отправка частей HTML в браузер по мере создания страницы на бэкенде. Более подробная информация о технике может быть найдена в соответствующей документации.

</details>

### 14. Почему вы бы использовали атрибут **`srcset`** в теге изображения?

<details>
<summary>Показать ответ</summary>

**Краткий ответ:**
Атрибут `srcset` используется, когда необходимо предоставлять различные изображения пользователям в зависимости от ширины дисплея их устройства — более качественные изображения для устройств с дисплеем Retina и изображения с меньшим разрешением для менее мощных устройств.

**Процесс оценки содержимого атрибута браузером**

Вы бы использовали атрибут `srcset`, когда хотите предоставить разные изображения пользователям в зависимости от ширины дисплея их устройства. Предоставление изображений более высокого качества устройствам с дисплеем Retina улучшает пользовательский опыт, в то время как предоставление изображений с более низким разрешением менее мощным устройствам повышает производительность и снижает расход трафика (поскольку предоставление более крупного изображения не даст никакой видимой разницы).

**Пример кода**

```html
<img
  srcset="small.jpg 500w, medium.jpg 1000w, large.jpg 2000w"
  src="..."
  alt=""
/>
```

Этот код сообщает браузеру отображать маленькую, среднюю или большую графику `.jpg` в зависимости от разрешения клиента. Первое значение — это имя изображения, а второе — ширина изображения в пикселях.

**Механизм работы**

Для устройства с шириной экрана 320px выполняются следующие расчеты:

- 500 / 320 = 1.5625
- 1000 / 320 = 3.125
- 2000 / 320 = 6.25

Если разрешение клиента 1x, то 1.5625 является ближайшим, и `500w`, соответствующий `small.jpg`, будет выбран браузером.

Если разрешение Retina (2x), браузер будет использовать ближайшее разрешение выше минимального. Это значит, что он не выберет 500w (1.5625), потому что это значение больше 1, и изображение может выглядеть плохо. Браузер выберет изображение с результирующим соотношением, близким к 2, то есть 1000w (3.125).

**Преимущества использования**

Атрибут `srcset` решает проблему, когда вы хотите предоставить файлы изображений меньшего размера для устройств с узким экраном, поскольку им не нужны огромные изображения, как для настольных дисплеев. Также он позволяет опционально предоставлять изображения разного разрешения для экранов с высокой/низкой плотностью пикселей.

</details>

### 15. В чем разница между событием **`load`** и событием **`DOMContentLoaded`** документа?

<details>
<summary>Показать ответ</summary>

**Краткий ответ:**
Событие `DOMContentLoaded` срабатывает, когда исходный HTML-документ полностью загружен и проанализирован, не дожидаясь загрузки таблиц стилей, изображений и подфреймов. Событие `load`, напротив, срабатывает, когда вся страница, включая все зависимые ресурсы, такие как таблицы стилей и изображения, полностью загружена.

**Событие DOMContentLoaded**

Событие `DOMContentLoaded` срабатывает, когда исходный HTML-документ полностью загружен и проанализирован, без ожидания загрузки таблиц стилей, изображений и подфреймов. Это событие полезно, когда вы хотите выполнить JavaScript-код, как только DOM будет готов, не дожидаясь полной загрузки всех ресурсов.

```javascript
document.addEventListener("DOMContentLoaded", function () {
  console.log("DOM fully loaded and parsed");
});
```

**Событие load**

Событие `load` срабатывает, когда вся страница, включая все зависимые ресурсы, такие как таблицы стилей, изображения и подфреймы, полностью загружена. Это событие полезно, когда необходимо выполнить действия, требующие полной загрузки всех ресурсов, например, инициализировать слайдшоу или выполнить расчеты макета, зависящие от размеров изображений.

```javascript
window.addEventListener("load", function () {
  console.log("Page fully loaded");
});
```

**Ключевые отличия**

- **Время срабатывания**: `DOMContentLoaded` срабатывает раньше, чем `load`. `DOMContentLoaded` происходит после полного анализа HTML, в то время как `load` ожидает загрузки всех ресурсов.
- **Варианты использования**: Используйте `DOMContentLoaded` для задач, которые требуют только готовности DOM, таких как прикрепление обработчиков событий или манипулирование DOM. Используйте `load` для задач, зависящих от полной загрузки всех ресурсов, таких как расчеты макета, зависящие от изображений.
</details>

### 16. На какие аспекты следует обратить внимание при проектировании или разработке **многоязычных сайтов**?

<details>
<summary>Показать ответ</summary>

**Краткий ответ:**
При разработке многоязычных сайтов нужно учитывать SEO-оптимизацию, различия между локалью и языком, предсказывание локали пользователя, разницу в длине текста на разных языках, направление чтения и особенности конкатенации строк.

**Подробное объяснение**

Проектирование и разработка многоязычных сайтов является частью интернационализации (i18n).

**Поисковая оптимизация (SEO)**

- Используйте атрибут `lang` в теге `<html>`.
- Включайте локаль в URL (например, en_US, zh_CN и т.д.).
- Веб-страницы должны использовать `<link rel="alternate" hreflang="other_locale" href="url_for_other_locale">`, чтобы сообщить поисковым системам, что существует другая страница по указанному href с тем же содержимым, но для другого языка/локали.
- Используйте резервную страницу для несопоставленных языков. Используйте значение "x-default": `<link rel="alternate" href="url_for_fallback" hreflang="x-default" />`.

**Понимание разницы между локалью и языком**

- Настройки локали контролируют отображение чисел, дат и времени для вашего региона: это может быть страна, часть страны или даже не учитывать границы стран.
- Язык может различаться между странами.
- Определенные языки, особенно широко распространенные, имеют разные "варианты" в разных странах (правила грамматики, правописание, символы). Важно различать языки для целевой страны и не предполагать/навязывать версию языка одной страны для всех стран, которые говорят на этом языке. Примеры:
  - en: en-US (американский английский), en-GB (британский английский)
  - zh: zh-CN (китайский (упрощенный)), zh-TW (китайский (традиционный))

**Предсказывайте локаль, но не ограничивайте**

Серверы могут определять локаль/язык посетителей с помощью комбинации заголовков HTTP Accept-Language и IP-адресов. С их помощью серверы могут автоматически выбирать наиболее подходящую локаль для посетителя. Однако прогнозы не являются надежными (особенно если посетители используют VPN), и посетителям все равно должна быть предоставлена возможность легко менять свою страну/язык без затруднений.

**Учитывайте различия в длине текста на разных языках**

Некоторый контент может быть длиннее при написании на другом языке. Остерегайтесь проблем с макетом или переполнением в дизайне. Лучше всего избегать дизайна, где количество текста может нарушить дизайн. Количество символов играет роль в таких элементах, как заголовки, метки и кнопки. Они меньше влияют на свободно текущий текст, например, основной текст или комментарии. Например, некоторые языки, такие как немецкий и французский, как правило, используют более длинные слова и предложения, чем английский, что может вызвать проблемы с макетом, если вы не учтете это.

**Направление чтения языка**

Языки, такие как английский и французский, пишутся слева направо, сверху вниз. Однако некоторые языки, такие как иврит и арабский, пишутся справа налево. Это может повлиять на макет вашего сайта и размещение элементов на странице, поэтому вы должны тщательно проектировать свой сайт таким образом, чтобы учитывать различные направления текста.

**Не конкатенируйте переведенные строки**

Не делайте ничего вроде "Сегодняшняя дата " + date. Это не будет работать в языках с другим порядком слов. Вместо этого используйте строку шаблона с подстановкой параметров для каждого языка. Например, сравните следующие два предложения на английском и китайском языках соответственно: "I will travel on {% date %}" и "我会在{% date %}旅行" - порядок слов отличается.

</details>

### 17. Как вы предоставляете страницу с содержимым на **нескольких языках**?

<details>
<summary>Показать ответ</summary>

**Краткий ответ:**
Для предоставления страницы на разных языках используется механизм определения языковых предпочтений пользователя через заголовок `Accept-Language`, указание атрибута `lang` в HTML и использование тегов `<link>` с атрибутами `rel="alternate"` и `hreflang` для сообщения поисковым системам о наличии версий на разных языках.

**Подробное объяснение**

_Предположение: вопрос о том, как предоставлять страницу с содержимым, доступным на нескольких языках, и содержимое на странице должно отображаться только на одном последовательном языке._

Предоставление страницы на разных языках является одним из аспектов интернационализации (i18n).

**Определение языка пользователя**

Когда HTTP-запрос отправляется на сервер, пользовательский агент обычно отправляет информацию о языковых предпочтениях, например, в заголовке `Accept-Language`. Затем сервер может использовать эту информацию, чтобы вернуть версию документа на соответствующем языке, если такая альтернатива доступна.

Возвращаемый HTML-документ также должен объявлять атрибут `lang` в теге `<html>`, например, `<html lang="en">...</html>`.

**Информирование поисковых систем**

Чтобы сообщить поисковой системе, что один и тот же контент доступен на разных языках, следует использовать теги `<link>` с атрибутами `rel="alternate"` и `hreflang="..."`. Например:

```html
<link rel="alternate" hreflang="de" href="http://de.example.com/page.html" />
```

**Методы рендеринга**

- **Серверный рендеринг (Server-side rendering):** HTML-разметка будет содержать заполнители строк, а содержимое для конкретного языка будет извлекаться из конфигурации в коде или из службы перевода. Затем сервер динамически генерирует HTML-страницу с содержимым на определенном языке.

- **Клиентский рендеринг (Client-side rendering):** Соответствующие строки локали будут извлечены и объединены с представлениями на основе JavaScript.
</details>

### 18. Что делает **`DOCTYPE`**?

<details>
<summary>Показать ответ</summary>

**Краткий ответ:**
**DOCTYPE** (сокращение от Document Type) сообщает браузеру, какую версию спецификации HTML использует документ, что влияет на режим отображения страницы (стандартный режим или режим совместимости).

**Подробное объяснение**

**DOCTYPE** — это сокращение от **Document Type** (тип документа). DOCTYPE всегда связан с **DTD** — **Document Type Definition** (определение типа документа).

DTD определяет, как должны быть структурированы документы определенного типа (например, `button` может содержать `span`, но не `div`), тогда как DOCTYPE объявляет, какой DTD документ _предположительно_ соблюдает (то есть этот документ соответствует HTML DTD).

**Роль DOCTYPE в веб-страницах**

Для веб-страниц объявление DOCTYPE является обязательным. Оно используется, чтобы сообщить пользовательским агентам (браузерам), какую версию спецификаций HTML соблюдает ваш документ.

Когда пользовательский агент распознает правильный DOCTYPE, он активирует **стандартный режим** (no-quirks mode), соответствующий этому DOCTYPE для чтения документа. Если пользовательский агент не распознает правильный DOCTYPE, он активирует **режим совместимости** (quirks mode).

**DOCTYPE в HTML5**

Объявление DOCTYPE для стандартов HTML5 выглядит так:

```html
<!DOCTYPE html>
```

Это самое простое и короткое объявление DOCTYPE, которое указывает на использование современных стандартов HTML.

</details>

### 19. Объясните, что такое **одностраничное приложение** и как сделать его **SEO-дружественным**

<details>
<summary>Показать ответ</summary>

**Краткий ответ:**
Одностраничное приложение (SPA) — это веб-приложение, которое загружает один HTML-документ и динамически обновляет содержимое при взаимодействии пользователя с приложением. Этот подход обеспечивает более плавный пользовательский опыт, но может создавать проблемы для SEO, поскольку поисковые системы могут не выполнять JavaScript для рендеринга содержимого. Чтобы сделать SPA SEO-дружественным, можно использовать серверный рендеринг (SSR) или генерацию статических сайтов (SSG). Инструменты вроде Next.js для React или Nuxt.js для Vue.js помогают достичь этой цели.

**Что такое одностраничное приложение?**

**Определение**

Одностраничное приложение (Single Page Application, SPA) — это веб-приложение, которое взаимодействует с пользователем путем динамического переписывания текущей страницы, а не загрузки полностью новых страниц с сервера. Это обеспечивает более плавный пользовательский опыт, схожий с настольным приложением.

**Ключевые характеристики**

- Приложение загружает одну HTML-страницу и динамически обновляет ее по мере взаимодействия пользователя с приложением
- Использует AJAX или Fetch API для обмена данными с сервером и обновления страницы без полной перезагрузки
- Часто полагается на клиентскую маршрутизацию для управления различными представлениями или состояниями внутри приложения

**Преимущества**

- Более быстрые взаимодействия после начальной загрузки
- Снижение нагрузки на сервер благодаря уменьшению количества запросов полных страниц
- Улучшенный пользовательский опыт с более плавными переходами

**Как сделать SPA SEO-дружественным**

**Проблемы**

SPA могут создавать проблемы для SEO, поскольку поисковые системы могут не выполнять JavaScript для рендеринга содержимого. Это может привести к тому, что поисковые системы проиндексируют пустую или неполную страницу.

**Решения**

**Серверный рендеринг (Server-Side Rendering, SSR)**

Серверный рендеринг включает генерацию исходного HTML страницы на сервере перед отправкой его клиенту. Это гарантирует, что поисковые системы смогут проиндексировать полностью отрендеренное содержимое.

- React: Используйте Next.js, который предоставляет встроенную поддержку SSR
- Vue.js: Используйте Nuxt.js, который также поддерживает SSR из коробки

**Пример с Next.js:**

```javascript
import React from "react";
import { GetServerSideProps } from "next";

const Page = ({ data }) => {
  return (
    <div>
      <h1>{data.title}</h1>
      <p>{data.content}</p>
    </div>
  );
};

export const getServerSideProps: GetServerSideProps = async () => {
  const res = await fetch("https://api.example.com/data");
  const data = await res.json();
  return {
    props: {
      data,
    },
  };
};

export default Page;
```

**Генерация статических сайтов (Static Site Generation, SSG)**

Генерация статических сайтов включает создание HTML для каждой страницы во время сборки. Этот подход подходит для контента, который не часто меняется.

- React: Используйте Next.js с его возможностями статической генерации
- Vue.js: Используйте Nuxt.js с его функцией генерации статических сайтов

**Пример с Next.js:**

```javascript
import React from "react";
import { GetStaticProps } from "next";

const Page = ({ data }) => {
  return (
    <div>
      <h1>{data.title}</h1>
      <p>{data.content}</p>
    </div>
  );
};

export const getStaticProps: GetStaticProps = async () => {
  const res = await fetch("https://api.example.com/data");
  const data = await res.json();
  return {
    props: {
      data,
    },
  };
};

export default Page;
```

**Пре-рендеринг с помощью инструментов**

Некоторые инструменты могут пре-рендерить ваше SPA и подавать пре-рендеренный HTML поисковым системам.

- **Prerender.io**: Сервис, который пре-рендерит ваше JavaScript-приложение и подает статический HTML поисковым системам
- **Rendertron**: Решение для рендеринга через безголовый Chrome, которое может использоваться для пре-рендеринга вашего SPA
</details>

### 20. Когда следует использовать **`document.write()`**?

<details>
<summary>Показать ответ</summary>

**Краткий ответ:**
`document.write()` редко используется в современной веб-разработке, поскольку может перезаписать весь документ, если вызывается после загрузки страницы. В основном применяется для простых задач, таких как запись содержимого во время начальной загрузки страницы, в образовательных целях или для быстрой отладки. Однако в целом рекомендуется использовать другие методы, такие как `innerHTML`, `appendChild()` или современные фреймворки для манипуляции с DOM.

**Случаи использования document.write()**

**Начальная загрузка страницы**

`document.write()` может использоваться для непосредственной записи содержимого в документ во время начальной загрузки страницы. Это один из немногих сценариев, где его использование может быть уместным, поскольку для очень простых задач он может быть проще и быстрее.

```html
<!DOCTYPE html>
<html>
  <head>
    <title>Document Write Example</title>
  </head>
  <body>
    <script>
      document.write("<h1>Hello, World!</h1>");
    </script>
  </body>
</html>
```

**Образовательные цели**

`document.write()` иногда используется в образовательных контекстах для демонстрации базовых концепций JavaScript. Он предоставляет простой способ показать, как JavaScript может манипулировать DOM.

**Быстрая отладка**

Для быстрой и черновой отладки `document.write()` может использоваться для вывода переменных или сообщений непосредственно в документ. Однако это не рекомендуется для рабочего кода.

```javascript
var debugMessage = "Debugging message";
document.write(debugMessage);
```

**Устаревший код**

В некоторых старых кодовых базах вы можете встретить `document.write()`. Хотя не рекомендуется использовать его в новых проектах, понимание его работы может быть полезным для поддержки или рефакторинга устаревшего кода.

**Почему не стоит использовать `document.write()`?**

- **Перезаписывает документ**: Если вызывается после загрузки страницы, `document.write()` перезапишет весь документ, что может привести к потере содержимого и плохому пользовательскому опыту.
- **Есть лучшие альтернативы**: Современные методы, такие как `innerHTML`, `appendChild()`, и фреймворки вроде React или Vue предоставляют больше контроля и более безопасны в использовании.

```javascript
// Использование innerHTML
document.getElementById("content").innerHTML = "<h1>Hello, World!</h1>";

// Использование appendChild
var newElement = document.createElement("h1");
newElement.textContent = "Hello, World!";
document.getElementById("content").appendChild(newElement);
```

</details>
