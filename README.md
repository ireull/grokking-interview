# grokking-css
Grokking css questions blitz style question and answer type questions


1.Объясните ваше понимание блочной модели (box model) и как вы бы указали браузеру в CSS рендерить ваш макет в разных блочных моделях.

<details>
<summary>Ответ</summary>
Блочная модель (Box Model)
Блочная модель описывает, как элемент представляется и отображается в браузере. Она состоит из:

Content (содержимое) - текст, изображения и т.д.
Padding (внутренний отступ) - пространство между содержимым и границей
Border (граница) - линия вокруг padding и содержимого
Margin (внешний отступ) - пространство за границей

Правила блочной модели:

Размеры блочного элемента рассчитываются из width, height, padding и border.
Если height не задана, блочный элемент будет высотой равен содержимому плюс padding (за исключением плавающих элементов).
Если width не задана, не-плавающий блочный элемент расширится до ширины родителя минус padding, если не установлено свойство max-width.

Некоторые блочные элементы (например, table, figure и input) имеют собственные значения ширины по умолчанию.
Примечание: span - строчный элемент и не имеет ширины по умолчанию.

height элемента рассчитывается высотой содержимого.
width элемента рассчитывается шириной содержимого.
По умолчанию (box-sizing: content-box), padding и border не являются частью width и height элемента.

Обратите внимание, что margin не учитывается в фактическом размере блока. Он влияет на общее пространство, которое блок занимает на странице, но только за пределами блока. Область блока заканчивается на border и не распространяется на margin.
Управление блочной моделью через CSS
Для изменения поведения блочной модели используется свойство box-sizing:

```css
/_ Стандартная блочная модель (по умолчанию) _/ .content-box {
  box-sizing: content-box;
}

/_ Альтернативная блочная модель _/ .border-box {
  box-sizing: border-box;
}

/_ Применение border-box ко всем элементам _/ - {
  box-sizing: border-box;
}
```

box-sizing: content-box (стандартная модель)
Это значение по умолчанию, при котором:

width/height = контент
общая ширина = width + padding + border
общая высота = height + padding + border

box-sizing: border-box (альтернативная модель)
При этой модели:

width/height = контент + padding + border
общая ширина = width (включает контент, padding и border)
общая высота = height (включает контент, padding и border)

Многие разработчики предпочитают border-box, потому что эта модель более интуитивно понятна, и многие CSS-фреймворки (Bootstrap, Tailwind, Bulma) устанавливают box-sizing: border-box глобально.

[The box model | MDN](https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Styling_basics/Box_model#the_standard_css_box_model)

</details>

## 2. Как манипулировать CSS стилями с помощью JavaScript?

<details>
<summary>Ответ</summary>

### Краткий ответ

Вы можете манипулировать CSS стилями с помощью JavaScript, обращаясь к свойству `style` HTML-элемента. Например, чтобы изменить цвет фона элемента `div` с id `myDiv`, можно использовать:

```js
document.getElementById("myDiv").style.backgroundColor = "blue";
```

Также можно добавлять, удалять или переключать CSS-классы с помощью свойства `classList`:

```js
document.getElementById("myDiv").classList.add("newClass");
document.getElementById("myDiv").classList.remove("oldClass");
document.getElementById("myDiv").classList.toggle("toggleClass");
```

### Манипулирование CSS стилями с помощью JavaScript

#### Доступ и изменение встроенных стилей

Вы можете напрямую управлять встроенными стилями HTML-элемента, используя свойство `style`. Это свойство позволяет устанавливать отдельные CSS-свойства.

```js
// Выбор элемента
const myDiv = document.getElementById("myDiv");
// Изменение цвета фона
myDiv.style.backgroundColor = "blue";
// Установка нескольких стилей
myDiv.style.width = "100px";
myDiv.style.height = "100px";
myDiv.style.border = "1px solid black";
```

#### Использование свойства `classList`

Свойство `classList` предоставляет методы для добавления, удаления и переключения CSS-классов элемента. Это полезно для применения предопределенных стилей из ваших CSS-файлов.

```js
// Выбор элемента
const myDiv = document.getElementById("myDiv");
// Добавление класса
myDiv.classList.add("newClass");
// Удаление класса
myDiv.classList.remove("oldClass");
// Переключение класса
myDiv.classList.toggle("toggleClass");
```

#### Изменение стилей с использованием CSS-переменных

CSS-переменные (пользовательские свойства) можно изменять с помощью JavaScript. Это особенно полезно для создания тем и динамического стилизации.

```js
// Установка CSS-переменной
document.documentElement.style.setProperty("--main-color", "blue");
// Получение значения CSS-переменной
const mainColor = getComputedStyle(document.documentElement).getPropertyValue(
  "--main-color"
);
console.log(mainColor);
```

#### Использование внешних таблиц стилей

Вы также можете управлять стилями, динамически добавляя или удаляя таблицы стилей.

```js
// Создание нового элемента link
const link = document.createElement("link");
link.rel = "stylesheet";
link.href = "styles.css";
// Добавление элемента link в head
document.head.appendChild(link);
// Удаление элемента link
document.head.removeChild(link);
```

</details>

## 3. Знакомы ли вы со стилизацией SVG?

<details>
<summary>Ответ</summary>

Существует несколько способов окрашивания фигур в SVG (включая задание атрибутов объекта) с использованием встроенного CSS, встроенной секции CSS или внешнего CSS-файла. Большинство SVG в интернете используют встроенный CSS, но у каждого типа есть свои преимущества и недостатки.

Базовая окраска может быть выполнена путем установки двух атрибутов для узла: `fill` и `stroke`. `fill` устанавливает цвет внутри объекта, а `stroke` устанавливает цвет линии, нарисованной вокруг объекта. Вы можете использовать те же схемы именования цветов CSS, что и в HTML, будь то названия цветов (например, `red`), значения RGB (например, `rgb(255,0,0)`), шестнадцатеричные значения, значения RGBA и т.д.

```js
<rect
  x="10"
  y="10"
  width="100"
  height="100"
  stroke="blue"
  fill="purple"
  fill-opacity="0.5"
  stroke-opacity="0.8"
/>
```

Вышеприведенный `fill="purple"` является примером _презентационного атрибута_. Интересно, что в отличие от встроенных стилей, таких как `style="fill: purple"`, которые также являются атрибутами, презентационные атрибуты могут быть **переопределены стилями CSS**, определенными в таблице стилей. Таким образом, если вы сделаете что-то вроде `svg { fill: blue; }`, это переопределит фиолетовую заливку, которая была определена.

</details>

Создам в формате таблицы, как на фото, с вопросами начиная с #4:

### 4. Вопрос:

**В чем разница между `block`, `inline` и `inline-block`?**

<details>
<summary>Ответ:</summary>

| Свойство                                       | Block                                                                                                   | Inline-Block                                                                                                            | Inline                                                                                                                                                                                                                                      |
| ---------------------------------------------- | ------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Размер                                         | Заполняет всю ширину родительского контейнера.                                                          | Зависит от контента.                                                                                                    | Зависит от контента.                                                                                                                                                                                                                        |
| Позиционирование                               | Начинается с новой строки и не допускает других элементов рядом с ним (кроме когда добавляете `float`). | Течет вместе с другим контентом и позволяет другим элементам находиться рядом.                                          | Течет вместе с другим контентом и позволяет другим элементам находиться рядом.                                                                                                                                                              |
| Может указывать `width` и `height`             | Да                                                                                                      | Да                                                                                                                      | Нет. Будет игнорировать, если задано.                                                                                                                                                                                                       |
| Может быть выровнен с помощью `vertical-align` | Нет                                                                                                     | Да                                                                                                                      | Да                                                                                                                                                                                                                                          |
| Margin и padding                               | Все стороны соблюдаются.                                                                                | Все стороны соблюдаются.                                                                                                | Только горизонтальные стороны соблюдаются. Вертикальные стороны, если указаны, не влияют на макет. Вертикальное пространство, которое занимает, зависит от `line-height`, хотя `border` и `padding` визуально отображаются вокруг контента. |
| Float                                          | -                                                                                                       | -                                                                                                                       | Становится как `block` элемент, где можно задать вертикальные margin и padding.                                                                                                                                                             |
| Варианты использования                         | Элементы макета, такие как `div`, `section`.                                                            | Используется для кнопок, изображений и полей форм, которым нужны настраиваемые размеры, но остаются в строке с текстом. | Ссылки (`a`), текстовое форматирование (`span`), стилизация текста - жирный (`b`), курсив (`i`).                                                                                                                                            |

</details>

### 5. Что делает `* { box-sizing: border-box; }`? Каковы его преимущества?

<details>
<summary>Ответ:</summary>

`* { box-sizing: border-box; }` заставляет каждый элемент на странице использовать подход `box-sizing: border-box` для расчета `height` и `width` элементов.

**В чем разница?**

По умолчанию элементы имеют применённый `box-sizing: content-box`, и учитывается только размер контента, если у элемента указаны `height` и `width`. `box-sizing: border-box` меняет способ расчета `width` и `height` элементов, `border` и `padding` также включаются в расчет. Высота элемента теперь рассчитывается как `height` контента + вертикальный `padding` + ширина вертикального `border`. Ширина элемента теперь рассчитывается как `width` контента + горизонтальный `padding` + ширина горизонтального `border`.

В следующей таблице указано, включается ли свойство в расчет высоты и ширины элемента при соответствующем `box-sizing`:

| Свойство  | `box-sizing: content-box` (по умолчанию) | `box-sizing: border-box` |
| --------- | ---------------------------------------- | ------------------------ |
| content   | Да                                       | Да                       |
| `padding` | Нет                                      | Да                       |
| `border`  | Нет                                      | Да                       |
| `margin`  | Нет                                      | Нет                      |

**Преимущества**

Учет `padding` и `border` как части box-модели лучше соответствует тому, как дизайнеры на самом деле представляют контент в сетках. Это гораздо более интуитивный способ думать о блоках, и поэтому многие CSS-фреймворки устанавливают `* { box-sizing: border-box; }` глобально, чтобы все элементы по умолчанию использовали такую box-модель.

</details>

### 6. Что такое свойство CSS `display` и можете ли вы привести несколько примеров его использования?

<details>
<summary>Ответ:</summary>

Общие значения для свойства `display`:

| Значение       | Описание                                                                                                                                                                                             |
| -------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `none`         | Не отображает элемент (элемент больше не влияет на макет страницы). Все дочерние элементы также не отображаются. Документ отрисовывается так, как если бы элемент не существовал в дереве документа. |
| `block`        | Элемент занимает всю строку в блочном направлении (обычно по горизонтали).                                                                                                                           |
| `inline`       | Элементы могут располагаться рядом друг с другом.                                                                                                                                                    |
| `inline-block` | Похоже на `inline`, но позволяет использовать некоторые свойства `block`, такие как установка `width` и `height`.                                                                                    |
| `flex`         | Ведет себя как блочный элемент уровня `flex`, которым можно управлять с помощью модели flexbox.                                                                                                      |
| `grid`         | Ведет себя как блочный элемент уровня `grid` с использованием grid-разметки.                                                                                                                         |
| `table`        | Ведет себя как элемент `<table>`.                                                                                                                                                                    |
| `table-row`    | Ведет себя как элемент `<tr>`.                                                                                                                                                                       |
| `table-cell`   | Ведет себя как элемент `<td>`.                                                                                                                                                                       |
| `list-item`    | Ведет себя как элемент `<li>`, который позволяет определить `list-style-type` и `list-style-position`.                                                                                               |

</details>

### 7. В чем разница между элементами, у которых позиционирование задано как `relative`, `fixed`, `absolute`, `sticky` и `static`?

<details>
<summary>Ответ:</summary>

Позиционированный элемент — это элемент, у которого вычисленное свойство `position` имеет значение `relative`, `absolute`, `fixed` или `sticky`.

| Значение   | Описание                                                                                                                                                                                                                                                                                                                                                             |
| ---------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `static`   | Позиционирование по умолчанию; элемент размещается на странице как обычно. Свойства `top`, `right`, `bottom`, `left` и `z-index` не применяются.                                                                                                                                                                                                                     |
| `relative` | Положение элемента корректируется относительно самого себя, без изменения макета (оставляя промежуток, где элемент находился бы, если бы не был позиционирован).                                                                                                                                                                                                     |
| `absolute` | Элемент удаляется из потока страницы и позиционируется в указанной позиции относительно ближайшего позиционированного предка, если таковой имеется, или относительно начального содержащего блока. Абсолютно позиционированные блоки могут иметь отступы (margins), и они не схлопываются с другими отступами. Эти элементы не влияют на положение других элементов. |
| `fixed`    | Элемент удаляется из потока страницы и позиционируется в указанном положении относительно области просмотра и не двигается при прокрутке.                                                                                                                                                                                                                            |
| `sticky`   | Липкое позиционирование — это гибрид относительного и фиксированного позиционирования. Элемент обрабатывается как `relative`-позиционированный, пока не пересечет указанный порог, после чего он обрабатывается как `fixed`-позиционированный.                                                                                                                       |

</details>

### 8. Можете ли вы объяснить разницу между разработкой адаптивного веб-сайта и использованием стратегии "mobile-first"?

<details>
<summary>Ответ:</summary>

Эти два подхода не являются взаимоисключающими. Создание адаптивного веб-сайта означает, что некоторые элементы будут реагировать, адаптируя свой размер или другую функциональность в соответствии с размером экрана устройства, обычно шириной области просмотра, с помощью медиа-запросов CSS, например, делая размер шрифта меньше на маленьких устройствах.

```css
@media (min-width: 768px) {
  .my-class {
    font-size: 24px;
  }
}

@media (max-width: 767px) {
  .my-class {
    font-size: 12px;
  }
}
```

Стратегия "mobile-first" также является адаптивной, однако она предполагает, что мы должны по умолчанию определять все стили для мобильных устройств и только позже добавлять конкретные адаптивные правила для других устройств. Следуя предыдущему примеру:

```css
.my-class {
  font-size: 12px;
}

@media (min-width: 768px) {
  .my-class {
    font-size: 24px;
  }
}
```

Стратегия "mobile-first" имеет следующие основные преимущества:

- Она более производительна на мобильных устройствах, поскольку все применяемые для них правила не должны проверяться на соответствие медиа-запросам.
- Дизайны, ориентированные на мобильные устройства, с большей вероятностью будут пригодны для использования на устройствах с большими экранами (просто будут выглядеть более растянутыми, но все равно пригодными для использования). Однако обратное не всегда верно.
</details>

### 9. Можете ли вы привести пример свойства `@media`, отличного от `screen`?

<details>
<summary>Ответ:</summary>

Существует четыре типа свойств `@media` (включая `screen`):

- `all`: для всех типов медиа-устройств
- `print`: для принтеров
- `speech`: для программ чтения с экрана, которые "читают" страницу вслух
- `screen`: для экранов компьютеров, планшетов, смартфонов и т.д.

Вот пример использования типа медиа `print`:

```css
@media print {
  body {
    color: black;
  }
}
```

</details>

### 10. Опишите `float` и как он работает.

<details>
<summary>Ответ:</summary>

Float — это свойство позиционирования CSS. Элементы с плавающим размещением остаются частью потока страницы и влияют на позиционирование других элементов (например, текст будет обтекать плавающие элементы), в отличие от элементов с `position: absolute`, которые удаляются из потока страницы.

Свойство CSS `clear` может использоваться для расположения ниже элементов с `float: left`/`right`/`both`.

Если родительский элемент содержит только плавающие элементы, его высота будет схлопнута до нуля. Это можно исправить, очистив плавающие элементы после них в контейнере, но перед закрытием контейнера.

**Хак clearfix**

Хак `.clearfix` использует CSS **псевдоэлемент** (`::after`) для очистки плавающих элементов. Вместо установки `overflow` для родителя, вы применяете дополнительный класс `clearfix` к нему. Затем применяете следующий CSS:

```css
.clearfix::after {
  content: " ";
  visibility: hidden;
  display: block;
  height: 0;
  clear: both;
}
```

В качестве альтернативы можно задать родительскому элементу свойство `overflow: auto` или `overflow: hidden`, которое создаст новый контекст форматирования блока внутри дочерних элементов, и он расширится, чтобы вместить своих потомков.

**Интересный факт**

В старые добрые времена CSS-фреймворки, такие как Bootstrap 2, использовали свойство `float` для реализации своей системы сеток. Однако с появлением CSS Flexbox и Grid в наши дни необходимость в использовании свойства `float` значительно уменьшилась.

</details>

### 7. Опишите псевдоэлементы и расскажите, для чего они используются.

<details>
<summary>Ответ</summary>

**Псевдоэлемент** CSS — это ключевое слово, добавляемое к селектору, которое позволяет стилизовать определенную часть выбранного элемента (или элементов). Они могут использоваться для декорирования (`::first-line`, `::first-letter`) или добавления элементов в разметку (в сочетании с `content: ...`) без необходимости изменять саму разметку (`:before`, `:after`).

- `::first-line` и `::first-letter` могут использоваться для декорирования текста.
- Используются в хаке `.clearfix`, как показано выше, для добавления элемента с нулевым пространством с `clear: both`.
- Треугольные стрелки в всплывающих подсказках используют `::before` и `::after`. Это способствует разделению задач, поскольку треугольник считается частью стилизации, а не реального DOM.

**Примечания**

- Псевдоэлементы отличаются от **псевдоклассов**, которые используются для стилизации элемента на основе его _состояния_ (например, `:hover`, `:focus` и т.д.).
- Двойные двоеточия следует использовать вместо одинарного двоеточия, чтобы различать псевдоклассы и псевдоэлементы. Большинство браузеров поддерживают оба синтаксиса, поскольку это различие не было четко определено в устаревших спецификациях W3C.
</details>

### 8. Опишите, что вам нравится и не нравится в CSS-препроцессорах, которые вы использовали.

<details>
<summary>Ответ</summary>

**Нравится**

- В основном преимущества, упомянутые в **"Каковы преимущества/недостатки использования CSS-препроцессоров?"**.
- Less написан на JavaScript, что хорошо сочетается с Node.

**Не нравится**

- Sass полагается на `node-sass`, который является привязкой к LibSass, написанной на C++. Библиотеку часто приходится перекомпилировать при переключении между версиями Node.js.
- В Less имена переменных имеют префикс `@`, что может быть спутано с нативными ключевыми словами CSS, такими как правила `@media`, `@import` и `@font-face`.
</details>

### 9. Использовали ли вы когда-нибудь систему сеток, и если да, то какую предпочитаете?

<details>
<summary>Ответ</summary>

До того, как Flex стал популярным (примерно в 2014 году), система сеток на основе `float` была наиболее надежной, поскольку она до сих пор имеет наибольшую поддержку браузеров среди альтернативных существующих систем (flex, grid). Bootstrap использовал подход на основе `float` до Bootstrap 4, который перешел на подход на основе `flex`.

Сегодня `flex` является рекомендуемым подходом для создания систем сеток и имеет **достойную поддержку браузеров (99,64%)**.

Для самых смелых можно посмотреть на **CSS Grid Layout**, который использует новое свойство `grid`. Grid — это двумерная система компоновки на основе сетки, в отличие от Flexbox, который является одномерным.

</details>

### 10. Использовали ли вы с новыми спецификациями CSS Flexbox или Grid?

<details>
<summary>Ответ</summary>

Flexbox в основном предназначен для одномерных макетов, в то время как Grid предназначен для двумерных макетов.

Flexbox решает множество распространенных проблем в CSS, таких как вертикальное центрирование элементов внутри контейнера, закрепленный футер и т.д. Известные CSS-фреймворки, такие как Bootstrap и Bulma, основаны на Flexbox, и Flexbox по-прежнему является проверенным и надежным способом создания макетов.

Grid, безусловно, является наиболее интуитивно понятным подходом для создания макетов на основе сетки, но поддержка браузеров на данный момент не так широка. Многие проблемы с макетом уже можно решить с помощью Flexbox, поэтому большой необходимости в Grid нет.

</details>

### 11. Использовали ли вы или внедряли медиа-запросы или макеты/CSS, специфичные для мобильных устройств?

<details>
<summary>Ответ</summary>

Примером может быть преобразование stacked pill navigation в фиксированную нижнюю вкладочную навигацию после определенной точки останова.

</details>

### 12. Каковы некоторые "подводные камни" при написании эффективного CSS?

<details>
<summary>Ответ</summary>

Во-первых, нужно понимать, что браузеры сопоставляют селекторы справа налево (от ключевого селектора). Браузеры фильтруют элементы в DOM в соответствии с ключевым селектором и перемещаются вверх по родительским элементам, чтобы определить совпадения. Чем короче длина цепочки селекторов, тем быстрее браузер может определить, соответствует ли этот элемент селектору. Поэтому избегайте ключевых селекторов, которые являются тегами и универсальными селекторами. Они соответствуют большому количеству элементов, и браузерам придется проделать больше работы, чтобы определить, соответствуют ли родители.

Методология **BEM (Block Element Modifier)** рекомендует, чтобы всё имело один класс, а там, где вам нужна иерархия, она также встраивается в имя класса, что естественным образом делает селектор эффективным и легко переопределяемым.

Будьте осведомлены о том, какие свойства CSS **вызывают** перекомпоновку (reflow), перерисовку (repaint) и композитинг (compositing). По возможности избегайте написания стилей, которые изменяют макет (вызывают перекомпоновку).

</details>

### 13. Каковы преимущества/недостатки использования CSS-препроцессоров?

<details>
<summary>Ответ</summary>

**Преимущества**

- CSS становится более удобным в обслуживании.
- Легче писать вложенные селекторы.
- Переменные для согласованного оформления тем. Можно делиться файлами тем между различными проектами. Это не обязательно полезно с пользовательскими свойствами CSS (часто называемыми переменными CSS).
- Миксины для генерации повторяющегося CSS.
- Sass и Less имеют такие функции, как циклы, списки и карты, которые могут сделать конфигурацию более простой и менее многословной.
- Разделение кода на несколько файлов во время разработки. CSS-файлы тоже можно разделить, но для этого потребуется HTTP-запрос для загрузки каждого CSS-файла.

**Недостатки**

- Требуются инструменты для предварительной обработки. Время перекомпиляции может быть медленным.
- Не пишете в данный момент потенциально используемый CSS. Например, используя что-то вроде **postcss-loader** с **webpack**, вы можете писать потенциально совместимый в будущем CSS, позволяя использовать такие вещи, как переменные CSS вместо переменных Sass. Таким образом, вы изучаете новый синтаксис, который может окупиться, если/когда они станут стандартизированными.
</details>

### 14. Каковы различные способы визуально скрыть контент (и сделать его доступным только для программ чтения с экрана)?

<details>
<summary>Ответ</summary>

Эти техники связаны с доступностью (a11y).

**Малый/нулевой размер**
`width: 1px; height: 1px` и комбинация использования CSS clip, чтобы элемент занимал (едва ли) место на экране.
Использование `width: 0; height: 0` не рекомендуется, поскольку поисковые системы могут наказать за это, думая, что это имеет злонамеренное намерение, например, накрутку ключевых слов.

**Абсолютное позиционирование**
`position: absolute; left: -99999px` расположит элемент далеко за пределами экрана. Однако, согласно **статье WebAIM**:
**_Навигационные элементы, такие как ссылки и элементы управления формами, не должны быть скрыты за пределами экрана. Они всё еще будут доступны для навигации зрячим пользователям клавиатуры, но не будут для них видимы, если только их стиль не настроен так, чтобы они становились видимыми при получении фокуса клавиатуры._**
Используйте это только когда ваш контент содержит только текст.

**Отступ текста**
`text-indent: -9999px`. Это работает только для текста внутри элементов `block`. Как и в технике абсолютного позиционирования выше, элементы с возможностью фокусировки, имеющие этот стиль, всё равно будут доступны для фокусировки, что может вызвать путаницу у зрячих пользователей, использующих навигацию с клавиатуры.

**Неправильные способы**
Следующие способы являются неправильными, поскольку они скрывают контент от пользователя **И** программ чтения с экрана, что неверно, если цель - сделать его доступным только для программ чтения с экрана.

- `display: none`
- `visibility: hidden`
- Атрибут `hidden`

**Техники в реальном мире**
В идеале рекомендуется комбинировать вышеуказанные подходы, чтобы убедиться, что это работает правильно во всех браузерах.
Вместо того, чтобы реализовывать свой собственный способ удаления элемента из дерева рендеринга и дерева a11y, рекомендуется использовать один из следующих подходов из зрелых CSS-фреймворков, которые были проверены на многих веб-сайтах.

**Tailwind CSS**

```
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}
```

**Bootstrap CSS**

```
.visually-hidden,
.visually-hidden-focusable:not(:focus):not(:focus-within) {
  position: absolute !important;
  width: 1px !important;
  height: 1px !important;
  padding: 0 !important;
  margin: -1px !important;
  overflow: hidden !important;
  clip: rect(0, 0, 0, 0) !important;
  white-space: nowrap !important;
  border: 0 !important;
}
```

</details>

### 15. Каковы различные техники очистки и какая из них подходит для какого контекста?

<details>
<summary>Ответ</summary>

- Метод пустого `div`: `<div style="clear:both;"></div>`.
- Метод Clearfix: См. класс `.clearfix` выше.
- Метод `overflow: auto` или `overflow: hidden`: Родитель установит новый блочный контекст форматирования и расширится, чтобы содержать свои плавающие дочерние элементы.

В крупных проектах наличие служебного класса `.clearfix` будет очень полезным. `overflow: hidden` может обрезать дочерние элементы, если дочерний элемент выше родителя, и это не очень идеально.

</details>

### 16. Какие существующие CSS-фреймворки вы использовали локально или в продакшене?

<details>
<summary>Ответ</summary>

Как бы вы их изменили/улучшили?

- **Bootstrap**: Медленный цикл выпуска. Bootstrap 4 находился в альфа-версии почти 2 года. Будущие версии Bootstrap должны включать компонент кнопки-спиннера, поскольку он широко используется.
- **Semantic UI**: Структура исходного кода делает настройку темы чрезвычайно сложной для понимания. Его нестандартная система тематизации - это боль для настройки. Жестко закодированный путь конфигурации внутри библиотеки поставщика. Не хорошо спроектирован для переопределения переменных, в отличие от Bootstrap.
- **Bulma**: Требуется множество несемантических и излишних классов и разметки. Не обратно совместим. Обновление версий нарушает работу приложения неявным образом.
</details>

### 17. Что такое специфичность CSS-селектора и как она работает?

<details>
<summary>Ответ</summary>

Браузер определяет, какие стили показывать на элементе, в зависимости от специфичности CSS-правил. Мы предполагаем, что браузер уже определил правила, которые соответствуют конкретному элементу. Среди совпадающих правил специфичность, четыре значения, разделенные запятыми, `a, b, c, d`, вычисляются для каждого правила на основе следующего:

1. `a` - используются ли встроенные стили. Если объявление свойства является встроенным стилем элемента, `a` равно 1, иначе 0.
2. `b` - количество селекторов ID.
3. `c` - количество селекторов классов, атрибутов и псевдоклассов.
4. `d` - количество селекторов тегов и псевдоэлементов.

Полученная специфичность не является единственной числовой оценкой, а массивом значений, которые можно сравнивать столбец за столбцом. При сравнении селекторов, чтобы определить, какой из них имеет наивысшую специфичность, смотрите слева направо и сравнивайте наибольшее значение в каждом столбце. Таким образом, значение в столбце `b` будет переопределять значения в столбцах `c` и `d`, независимо от того, какими они могут быть. Поэтому специфичность `0, 1, 0, 0` будет больше, чем `0, 0, 10, 10`.

В случаях равной специфичности: считается последнее правило. Если вы написали одно и то же правило в своей таблице стилей (независимо от того, внутренняя она или внешняя) дважды, то нижнее правило в вашей таблице стилей находится ближе к элементу, который нужно стилизовать, оно считается более конкретным и поэтому будет применено.

Лучшей практикой является написание CSS-правил с низкой специфичностью, чтобы их можно было легко переопределить при необходимости. При написании кода библиотеки UI-компонентов CSS важно, чтобы они имели низкую специфичность, чтобы пользователи библиотеки могли переопределять их, не используя слишком сложные правила CSS только для увеличения специфичности или прибегая к `!important`.

</details>

### 18. Опишите Block Formatting Context (BFC) и как он работает.

<details>
<summary>Ответ</summary>

Block Formatting Context (BFC) является частью визуального рендеринга CSS веб-страницы, в которой размещаются блочные боксы. Плавающие элементы, абсолютно позиционированные элементы, `inline-blocks`, `table-cells`, `table-caption`s и элементы с `overflow`, отличным от `visible` (кроме случаев, когда это значение было распространено на область просмотра), устанавливают новые контексты форматирования блоков.

Знание того, как установить контекст форматирования блока, важно, потому что без этого содержащий блок не будет **содержать плавающие дочерние элементы**. Это похоже на схлопывание полей, но более коварно, так как вы обнаружите, что целые блоки схлопываются странным образом.

BFC - это HTML-блок, который удовлетворяет по крайней мере одному из следующих условий:

- Значение `float` не `none`.
- Значение `position` не `static` и не `relative`.
- Значение `display` - `table-cell`, `table-caption`, `inline-block`, `flex` или `inline-flex`, `grid` или `inline-grid`.
- Значение `overflow` не `visible`.

В BFC левый внешний край каждого блока касается левого края содержащего блока (для форматирования справа налево касаются правые края).

Вертикальные поля между соседними блочными элементами в BFC схлопываются. Подробнее о **схлопывающихся полях(https://developer.mozilla.org/ru/docs/Web/CSS/CSS_Box_Model/Mastering_margin_collapsing)**.

</details>

### 19. Опишите **`z-index`** и как формируется контекст наложения.

<details>
<summary>Ответ</summary>

Свойство `z-index` в CSS управляет вертикальным порядком наложения элементов, которые перекрываются. `z-index` влияет только на позиционированные элементы (элементы, у которых значение `position` отличается от `static`) и их потомков или элементы flex.

Без какого-либо значения `z-index` элементы накладываются в том порядке, в котором они появляются в DOM (самый нижний на том же уровне иерархии появляется сверху). Элементы с непозиционированным статическим позиционированием (и их дети) всегда будут отображаться поверх элементов с позиционированием по умолчанию, независимо от HTML-иерархии.

Контекст наложения - это элемент, который содержит набор слоев. В пределах локального контекста наложения значения `z-index` его дочерних элементов устанавливаются относительно этого элемента, а не корня документа. Слои за пределами этого контекста, т.е. родственные элементы локального контекста наложения, не могут находиться между слоями внутри него. Если элемент B располагается поверх элемента A, дочерний элемент элемента A, элемент C, никогда не может быть выше элемента B, даже если элемент C имеет более высокий `z-index`, чем элемент B.

Каждый контекст наложения является самодостаточным - после того, как содержимое элемента уложено, весь элемент учитывается в порядке наложения родительского контекста наложения. Ряд свойств CSS запускает новый контекст наложения, таких как `opacity` меньше 1, `filter`, отличный от `none`, и `transform`, отличный от `none`.

**\*Примечание\*\***: То, что именно квалифицирует элемент для создания контекста наложения, перечислено в этом длинном наборе \***\*правил(https://developer.mozilla.org/ru/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context#The_stacking_context)\*\***.\*

</details>

### 20. Объясните CSS-спрайты и как бы вы их реализовали на странице или сайте.

<details>
<summary>Ответ</summary>

CSS-спрайты объединяют несколько изображений в один большой файл изображения и используют комбинацию CSS `background-image`, `background-position` и `background-size` для выбора определенной части большего изображения в качестве нужного изображения.

Это была обычно используемая техника для иконок (например, Gmail использует спрайты для всех своих изображений).

**Преимущества**

- Уменьшение количества HTTP-запросов для нескольких изображений (требуется только один запрос на спрайт-лист). Но с HTTP2 загрузка нескольких изображений уже не является большой проблемой.
- Предварительная загрузка ресурсов, которые не будут загружены до необходимости, таких как изображения, которые отображаются только при псевдосостояниях `:hover`. Мерцание не будет видно.

**Как реализовать**

1. Используйте генератор спрайтов, который упаковывает несколько изображений в одно и генерирует соответствующий CSS для него.
2. Каждое изображение должно иметь соответствующий CSS-класс с определенными свойствами `background-image` и `background-position`.
3. Чтобы использовать это изображение, добавьте соответствующий класс к вашему элементу.

Сгенерированная таблица стилей может выглядеть примерно так:

```
.icon {
  background-image: url('https://example.com/images/spritesheet.png');
  width: 24px;
  height: 24px;
}
.icon-cart {
  background-position: 0 0;
}
.icon-arrow {
  background-position: -24px 0;
}
```

И может использоваться в HTML следующим образом:

```
<span class="icon icon-cart"></span>
<span class="icon icon-arrow"></span>
```

</details>

### 21. Объясните, как браузер определяет, какие элементы соответствуют CSS-селектору.

<details>
<summary>Ответ</summary>

Этот вопрос связан с вопросом о **написании эффективного CSS(https://www.greatfrontend.com/questions/quiz/what-are-some-of-the-gotchas-for-writing-efficient-css)**. Браузеры сопоставляют селекторы справа (ключевой селектор) налево. Браузеры фильтруют элементы в DOM в соответствии с ключевым селектором и проходят вверх по его родительским элементам, чтобы определить совпадения. Чем короче длина цепочки селектора, тем быстрее браузер может определить, соответствует ли этот элемент селектору.

Например, с селектором `p span`, браузеры сначала находят все элементы `<span>` и проходят вверх по его родителю до самого корня, чтобы найти элемент `<p>`. Для конкретного `<span>`, как только он находит `<p>`, он знает, что `<span>` соответствует селектору, и может прекратить обход его родителей.

</details>

### 22. Работали ли вы когда-нибудь с ретина-графикой?

<details>
<summary>Ответ</summary>

Если да, то когда и какие техники вы использовали?

_Retina_ - это просто маркетинговый термин для обозначения экранов с высоким разрешением с пиксельным соотношением больше 1. Ключевым моментом является то, что использование пиксельного соотношения означает, что эти дисплеи эмулируют экран с более низким разрешением, чтобы показывать элементы того же размера. В наши дни мы считаем все мобильные устройства дисплеями _retina_ по факту.

Браузеры по умолчанию отображают элементы DOM в соответствии с разрешением устройства, за исключением изображений.

Чтобы иметь четкую, привлекательную графику, которая максимально использует дисплеи retina, нам нужно использовать изображения с высоким разрешением, когда это возможно. Однако использование всегда изображений с самым высоким разрешением будет влиять на производительность, так как по сети нужно будет отправлять больше байтов.

Чтобы преодолеть эту проблему, мы можем использовать отзывчивые изображения, как указано в HTML5. Это требует предоставления браузеру различных файлов разрешения одного и того же изображения и позволяет ему решать, какое изображение лучше, используя HTML-атрибут `srcset` и, опционально, `sizes`, например:

```
<div responsive-background-image>
  <img
    src="/images/test-1600.jpg"
    sizes="
     (min-width: 768px) 50vw,
     (min-width: 1024px) 66vw,
     100vw"
    srcset="
     /images/test-400.jpg 400w,
     /images/test-800.jpg 800w,
     /images/test-1200.jpg 1200w
    " />
</div>
```

Важно отметить, что браузеры, которые не поддерживают HTML5 `srcset` (например, IE11), будут игнорировать его и использовать вместо этого `src`. Если нам действительно нужно поддерживать IE11, и мы хотим предоставить эту функцию для повышения производительности, мы можем использовать полифил JavaScript, например, **Picturefill(https://scottjehl.github.io/picturefill)**.

Для иконок, где это возможно, используйте SVG, так как они отображаются очень четко независимо от разрешения.

</details>

### 23. Как вы обслуживаете свои страницы для браузеров с ограниченными возможностями?

<details>
<summary>Ответ</summary>

Какие техники/процессы вы используете?

**Техники**

- Изящная деградация: Практика создания приложения для современных браузеров, гарантируя при этом, что оно остается функциональным в старых браузерах.
- Прогрессивное улучшение: Практика создания приложения для базового уровня пользовательского опыта, но добавление функциональных улучшений, когда браузер их поддерживает.
- Использование **caniuse.com** для проверки поддержки функций.
- Autoprefixer для автоматической вставки вендорных префиксов.
- Обнаружение функций с помощью **Modernizr**.
- Использование CSS Feature queries через `@support`
</details>

### 24. Чем отличается отзывчивый дизайн от адаптивного?

<details>
<summary>Ответ</summary>

И отзывчивый, и адаптивный дизайн пытаются оптимизировать пользовательский опыт на различных устройствах, регулируя для разных размеров viewport, разрешений, контекстов использования, механизмов управления и так далее.

Отзывчивый дизайн работает по принципу гибкости - один подвижный веб-сайт, который может хорошо выглядеть на любом устройстве. Отзывчивые веб-сайты используют медиа-запросы, гибкие сетки и отзывчивые изображения для создания пользовательского опыта, который изменяется и адаптируется на основе множества факторов. Как один мяч, который увеличивается или уменьшается, чтобы пройти через несколько разных обручей.

Адаптивный дизайн больше похож на современное определение прогрессивного улучшения. Вместо одного гибкого дизайна адаптивный дизайн определяет устройство и другие функции, а затем предоставляет соответствующие функции и макет на основе предопределенного набора размеров viewport и других характеристик. Сайт определяет тип используемого устройства и предоставляет предустановленный макет для этого устройства. Вместо одного мяча, проходящего через несколько обручей разного размера, у вас будет несколько разных мячей для использования в зависимости от размера обруча.

Оба эти метода имеют некоторые проблемы, которые необходимо взвесить:

- Отзывчивый дизайн может быть довольно сложным, поскольку вы по сути используете один, хотя и отзывчивый макет для всех ситуаций. Как установить точки останова медиа-запросов - это одна из таких проблем. Используете ли вы стандартизированные значения точек останова? Или вы используете точки останова, которые имеют смысл для вашего конкретного макета? А что, если этот макет изменится?
- Адаптивный дизайн обычно требует определения user agent, или определения DPI и т.д., все из которых могут оказаться ненадежными.
</details>

### 25. Как бы вы подошли к исправлению проблем стилизации, специфичных для браузера?

<details>
<summary>Ответ</summary>

- После выявления проблемы и нарушающего браузера используйте отдельную таблицу стилей, которая загружается только тогда, когда используется этот конкретный браузер. Однако эта техника требует рендеринга на стороне сервера.
- Используйте библиотеки, такие как Bootstrap, которые уже справляются с этими проблемами стилизации для вас.
- Используйте `autoprefixer` для автоматического добавления вендорных префиксов к вашему коду.
- Используйте Reset CSS или Normalize.css.
- Если вы используете PostCSS (или аналогичную библиотеку транспиляции CSS), могут быть плагины, которые позволяют вам включать использование современного синтаксиса CSS (и даже предложений W3C), которые преобразуют эти части вашего кода в эквивалентный обратно совместимый код, который будет работать в целевых браузерах, которые вы используете.
</details>

### 26. Есть ли причины, по которым вы захотели бы использовать **`translate()`** вместо **`absolute`** позиционирования, или наоборот? И почему?

<details>
<summary>Ответ</summary>

`translate()` - это возможное значение свойства CSS `transform`. При использовании `translate()` элемент все еще занимает свое исходное пространство (своего рода как `position: relative`). Но при изменении абсолютного позиционирования элементов, элементы удаляются из потока страницы, и позиционирование окружающих элементов будет затронуто. Следовательно, макет страницы должен быть пересчитан.

Изменение `transform` или `opacity` не вызывает перекомпоновку (reflow) или перерисовку (repaint) браузера, но вызывает композиции; С другой стороны, изменение абсолютного позиционирования вызывает `reflow`. `transform` заставляет браузер создавать слой GPU для элемента, но изменение свойств абсолютного позиционирования использует CPU. Следовательно, `translate()` более эффективен и приведет к более коротким временам отрисовки для более плавных анимаций.

</details>

### 27. Какая разница между "resetting" и "normalizing" CSS? Какой бы вы выбрали и почему?

<details>
<summary>Ответ</summary>

**Resetting (сброс CSS)**

Resetting означает удаление всех стилей браузера по умолчанию для элементов. Например, `margin`'s, `padding`'s, `font-size`'s всех элементов сбрасываются до одинаковых значений. Вам придется повторно объявить стили для типографских элементов.

**Normalizing (нормализация CSS)**

Normalizing сохраняет полезные стили браузера по умолчанию, а не "обнуляет" всё. Он также исправляет ошибки для распространенных зависимостей браузера.

**Что выбрать и почему?**

Выбирайте resetting, когда вам нужен очень настраиваемый или нестандартный дизайн сайта, такой, при котором вам нужно делать много собственной стилизации и не нужно сохранять какие-либо стили по умолчанию.

Выбирайте normalizing для более традиционных проектов, где вы хотите поддерживать консистентность между браузерами, сохраняя полезные стили по умолчанию. Normalize.css сохраняет то, что полезно, и корректирует распространенные недостатки, что делает его более тонким и поддерживаемым подходом для большинства проектов.

Я бы выбрал normalizing для большинства проектов, потому что это экономит время на переопределении распространенных стилей, которые уже хорошо работают, и при этом обеспечивает согласованность между браузерами. Он также лучше поддерживается и имеет более ясную цель, чем полный сброс CSS.

</details>
